# Web3 Deposit & Withdrawal Strategy (BEP20 & TRC20)

## ðŸ”´ **CRITICAL SECURITY ISSUE - CURRENT IMPLEMENTATION**

### **Problem 1: Shared Admin Wallet**
- **Current**: All withdrawals use a single admin wallet private key (from environment variables)
- **Risk**: If the private key is exposed, anyone can withdraw funds from the admin wallet
- **Issue**: All users' withdrawals come from the same wallet, not their own accounts

### **Problem 2: Platform Score vs. Real Balance**
- **Current**: Withdrawals are validated against `platformScore` (database value)
- **Issue**: Should validate against actual USDT balance in user's Web3Auth account address
- **Risk**: Users can withdraw more than they actually have in their Web3Auth wallet

---

## âœ… **CORRECT STRATEGY**

### **Core Principle: User-Owned Wallets**
Each user has their own Web3Auth account with:
- **Unique Address**: Generated by Web3Auth (e.g., `0xe2155dF874d660D6F9d9525B0AE6519A55b2aE7F`)
- **Private Key**: Accessible only to the user (via Web3Auth login)
- **Own Funds**: USDT deposited directly to their Web3Auth address

---

## ðŸ“¥ **DEPOSIT STRATEGY (BEP20 & TRC20)**

### **Flow Overview**

```
User â†’ Sends USDT â†’ User's Web3Auth Address â†’ Platform Credits Platform Score
```

### **Step-by-Step Process**

#### **1. User Initiates Deposit (Frontend)**

**BEP20 (BSC) Deposit:**
```javascript
// User's Web3Auth account address (where they will receive funds)
const depositAddress = safeAuthAccount; // e.g., "0xe2155dF874d660D6F9d9525B0AE6519A55b2aE7F"

// Display this address to user
// User sends USDT from their external wallet (MetaMask, etc.) to this address
```

**TRC20 (TRON) Deposit:**
```javascript
// For TRC20, we may need a backend-generated address OR use Web3Auth address
// If Web3Auth supports TRON addresses, use safeAuthAccount
// Otherwise, backend generates a unique TRC20 address per user
```

#### **2. User Sends USDT to Their Web3Auth Address**

**BEP20:**
- User opens MetaMask/Trust Wallet
- Sends USDT to their Web3Auth BSC address
- Transaction hash is generated

**TRC20:**
- User opens TronLink/Trust Wallet
- Sends USDT to their Web3Auth TRON address (or backend-generated address)
- Transaction hash is generated

#### **3. Backend Monitors Deposits**

**Deposit Watcher Service:**
```typescript
// Backend monitors blockchain for deposits to user addresses
// When deposit detected:
1. Verify transaction on blockchain
2. Check recipient address matches user's Web3Auth address
3. Verify amount
4. Credit user's platformScore in database
5. Record transaction in wallet_transactions table
```

**Key Points:**
- âœ… Deposits go directly to **user's Web3Auth address** (not admin wallet)
- âœ… Backend only **monitors** and **credits** platform score
- âœ… User owns the funds in their Web3Auth account
- âœ… Platform score is a **virtual balance** for gameplay

---

## ðŸ“¤ **WITHDRAWAL STRATEGY (BEP20 & TRC20)**

### **Flow Overview**

```
User Request â†’ Backend Gets User's Private Key â†’ User's Web3Auth Wallet â†’ User's Withdrawal Address
```

### **Step-by-Step Process**

#### **1. User Initiates Withdrawal (Frontend)**

```javascript
// User enters:
- Network: BEP20 or TRC20
- Withdrawal Address: User's chosen address (any address)
- Amount: Based on their Web3Auth wallet USDT balance (not platformScore)

// Frontend validates:
- User is connected to Web3Auth
- Withdrawal address format is valid (BEP20: 0x..., TRC20: T...)
- Amount <= actual USDT balance in Web3Auth account
```

#### **2. Frontend Retrieves User's Private Key from Web3Auth**

```javascript
// CRITICAL: Get private key from Web3Auth
const getWeb3AuthPrivateKey = async (web3auth) => {
  if (!web3auth || !web3auth.provider) {
    throw new Error('Web3Auth not connected');
  }
  
  try {
    // Method 1: Using Web3Auth provider (EIP-1193 standard)
    // Request private key from the provider
    const privateKey = await web3auth.provider.request({
      method: 'eth_private_key'
    });
    
    // Method 2: If Method 1 doesn't work, try using the private key provider directly
    // Web3Auth uses EthereumPrivateKeyProvider internally
    // The private key is stored in the provider's state
    if (!privateKey && web3auth.privateKeyProvider) {
      // Access the private key from the provider's internal state
      // Note: This depends on Web3Auth's internal implementation
      const providerState = await web3auth.provider.request({
        method: 'private_key'
      });
      return providerState;
    }
    
    // Method 3: Extract from ethers signer (if available)
    if (!privateKey) {
      const ethersProvider = new ethers.providers.Web3Provider(web3auth.provider);
      const signer = ethersProvider.getSigner();
      // Note: Standard ethers signers don't expose private keys
      // This method may not work with Web3Auth's provider
    }
    
    return privateKey;
  } catch (error) {
    console.error('Error getting private key from Web3Auth:', error);
    throw new Error('Failed to retrieve private key. Please ensure you are logged in to Web3Auth.');
  }
};
```

**âš ï¸ IMPORTANT NOTES:**
- Web3Auth's private key access depends on the adapter type and configuration
- For `OpenloginAdapter` (Google login), the private key is typically accessible via `provider.request({ method: 'eth_private_key' })`
- For external wallet connections (MetaMask), the private key is NOT accessible (wallet controls it)
- **Security**: Only retrieve private key when absolutely necessary (during withdrawal)
- **Storage**: Never store the private key in localStorage, sessionStorage, or any client-side storage

**âš ï¸ SECURITY NOTE:**
- Private key should be sent to backend **securely** (encrypted, HTTPS)
- Backend should **never store** the private key
- Use private key **only for the withdrawal transaction**, then discard

#### **3. Frontend Sends Withdrawal Request to Backend**

```javascript
const handleWithdraw = async () => {
  // Get user's private key from Web3Auth
  const userPrivateKey = await getWeb3AuthPrivateKey();
  
  // Send to backend
  const response = await apiService.post('/wallet/withdraw', {
    network: selectedNetwork, // 'BEP20' or 'TRC20'
    amount: withdrawAmount,
    fromAddress: safeAuthAccount, // User's Web3Auth address
    toAddress: withdrawalAddress, // User's chosen withdrawal address
    privateKey: userPrivateKey, // âš ï¸ SECURE: Encrypt before sending
  });
};
```

#### **4. Backend Processes Withdrawal**

**Backend Service (wallet.service.ts):**

```typescript
async processWithdrawal(userId: string, withdrawDto: WithdrawDto) {
  // 1. Validate user exists
  const user = await this.usersRepository.findOne({ where: { id: userId } });
  
  // 2. Get user's Web3Auth address from DTO
  const fromAddress = withdrawDto.fromAddress; // User's Web3Auth address
  
  // 3. âœ… CRITICAL: Check ACTUAL USDT balance on blockchain (not platformScore)
  let actualBalance: number;
  if (withdrawDto.network === 'BEP20') {
    actualBalance = await this.bscService.getBalance(fromAddress);
  } else if (withdrawDto.network === 'TRC20') {
    actualBalance = await this.tronService.getBalance(fromAddress);
  }
  
  // 4. Validate withdrawal amount against REAL balance
  if (withdrawDto.amount > actualBalance) {
    throw new BadRequestException(
      `Insufficient balance. Your Web3Auth wallet has ${actualBalance} USDT, but you requested ${withdrawDto.amount} USDT.`
    );
  }
  
  // 5. âœ… Use USER'S private key (from DTO) instead of admin wallet
  // Create temporary wallet instance with user's private key
  let txHash: string;
  
  if (withdrawDto.network === 'BEP20') {
    // BEP20: Use user's private key to create wallet
    const userWallet = new ethers.Wallet(withdrawDto.privateKey, this.bscService.getProvider());
    const usdtContract = new ethers.Contract(
      USDT_ADDRESS,
      USDT_ABI,
      userWallet // âœ… User's wallet, not admin wallet
    );
    
    const decimals = await usdtContract.decimals();
    const amountInWei = ethers.parseUnits(withdrawDto.amount.toString(), decimals);
    
    const tx = await usdtContract.transfer(withdrawDto.toAddress, amountInWei);
    const receipt = await tx.wait();
    txHash = receipt.hash;
    
  } else if (withdrawDto.network === 'TRC20') {
    // TRC20: Use user's private key to create TronWeb instance
    const userTronWeb = new TronWeb({
      fullHost: TRON_RPC_URL,
      privateKey: withdrawDto.privateKey, // âœ… User's private key
    });
    
    const usdtContract = await userTronWeb.contract().at(USDT_CONTRACT_ADDRESS);
    const decimals = 6; // USDT on TRON uses 6 decimals
    const amountInSun = parseFloat(withdrawDto.amount.toString()) * Math.pow(10, decimals);
    
    const tx = await usdtContract.transfer(withdrawDto.toAddress, amountInSun).send();
    txHash = tx;
  }
  
  // 6. Record transaction
  const transaction = this.transactionsRepository.create({
    walletId: wallet.id,
    type: TransactionType.WITHDRAWAL,
    status: TransactionStatus.CONFIRMED,
    network: withdrawDto.network,
    amount: withdrawDto.amount,
    fromAddress: fromAddress, // User's Web3Auth address
    toAddress: withdrawDto.toAddress,
    txHash: txHash,
  });
  await this.transactionsRepository.save(transaction);
  
  // 7. Deduct platform score (mirrors the withdrawal)
  await this.platformScoreService.deductScore(
    userId,
    withdrawDto.amount,
    `Withdrawal to ${withdrawDto.toAddress}`,
    transaction.id,
    'wallet_withdrawal'
  );
  
  return transaction;
}
```

---

## ðŸ” **SECURITY IMPLEMENTATION**

### **1. Private Key Handling**

**Frontend:**
```javascript
// âœ… GOOD: Encrypt private key before sending
import CryptoJS from 'crypto-js';

const encryptPrivateKey = (privateKey, userSessionToken) => {
  // Use user's session token as encryption key
  return CryptoJS.AES.encrypt(privateKey, userSessionToken).toString();
};

// Send encrypted private key
const encryptedKey = encryptPrivateKey(userPrivateKey, sessionToken);
```

**Backend:**
```typescript
// âœ… GOOD: Decrypt, use once, discard
const decryptPrivateKey = (encryptedKey: string, sessionToken: string): string => {
  const bytes = CryptoJS.AES.decrypt(encryptedKey, sessionToken);
  return bytes.toString(CryptoJS.enc.Utf8);
};

// Use private key ONLY for transaction
const privateKey = decryptPrivateKey(withdrawDto.encryptedPrivateKey, sessionToken);
// ... perform transaction ...
// âœ… Private key is now out of scope, garbage collected
```

### **2. Balance Validation**

**Always check blockchain balance, not database:**
```typescript
// âŒ BAD: Check platformScore
if (withdrawDto.amount > user.platformScore) { ... }

// âœ… GOOD: Check actual blockchain balance
const actualBalance = await blockchainService.getBalance(userWeb3AuthAddress);
if (withdrawDto.amount > actualBalance) { ... }
```

### **3. Address Validation**

```typescript
// BEP20: Must be valid Ethereum address format
const isValidBEP20Address = (address: string): boolean => {
  return /^0x[a-fA-F0-9]{40}$/.test(address);
};

// TRC20: Must be valid TRON address format
const isValidTRC20Address = (address: string): boolean => {
  return /^T[1-9A-HJ-NP-Za-km-z]{33}$/.test(address);
};
```

---

## ðŸ“Š **BEP20 (BSC) SPECIFIC IMPLEMENTATION**

### **Network Details**
- **Chain ID**: 56 (Mainnet), 97 (Testnet)
- **RPC URL**: `https://bsc-dataseed.binance.org/`
- **USDT Contract**: `0x55d398326f99059fF775485246999027B3197955`
- **Decimals**: 18
- **Gas Token**: BNB

### **Withdrawal Implementation**

```typescript
// Backend: bsc.service.ts
async transferWithUserKey(
  userPrivateKey: string,
  toAddress: string,
  amount: string
): Promise<{ txHash: string }> {
  // Create wallet from user's private key
  const userWallet = new ethers.Wallet(userPrivateKey, this.provider);
  
  // Check user's BNB balance for gas
  const bnbBalance = await this.provider.getBalance(userWallet.address);
  const bnbBalanceInBNB = parseFloat(ethers.formatEther(bnbBalance));
  
  if (bnbBalanceInBNB < 0.001) {
    throw new Error('Insufficient BNB for gas fees. User needs at least 0.001 BNB.');
  }
  
  // Create USDT contract instance with user's wallet
  const usdtContract = new ethers.Contract(
    this.USDTContractAddress,
    USDT_ABI,
    userWallet
  );
  
  // Get decimals
  const decimals = await usdtContract.decimals();
  const amountInWei = ethers.parseUnits(amount, decimals);
  
  // Transfer
  const tx = await usdtContract.transfer(toAddress, amountInWei);
  const receipt = await tx.wait();
  
  return { txHash: receipt.hash };
}
```

---

## ðŸ“Š **TRC20 (TRON) SPECIFIC IMPLEMENTATION**

### **Network Details**
- **Network**: TRON Mainnet
- **RPC URL**: `https://api.trongrid.io`
- **USDT Contract**: `TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t`
- **Decimals**: 6
- **Gas Token**: TRX (for Energy/Bandwidth)

### **Withdrawal Implementation**

```typescript
// Backend: tron.service.ts
async transferWithUserKey(
  userPrivateKey: string,
  toAddress: string,
  amount: string
): Promise<{ txHash: string }> {
  // Create TronWeb instance with user's private key
  const userTronWeb = new TronWeb({
    fullHost: this.configService.get('TRON_FULL_NODE'),
    privateKey: userPrivateKey, // âœ… User's private key
  });
  
  // Get user's TRX balance for gas
  const userAddress = userTronWeb.address.fromPrivateKey(userPrivateKey);
  const trxBalance = await userTronWeb.trx.getBalance(userAddress);
  const trxBalanceInTRX = trxBalance / 1000000;
  
  if (trxBalanceInTRX < 10) {
    throw new Error('Insufficient TRX for gas fees. User needs at least 10 TRX.');
  }
  
  // Create USDT contract instance
  const usdtContract = await userTronWeb.contract().at(this.USDTContractAddress);
  
  // Get decimals (USDT on TRON uses 6)
  const decimals = 6;
  const amountInSun = parseFloat(amount) * Math.pow(10, decimals);
  
  // Transfer
  const tx = await usdtContract.transfer(toAddress, amountInSun).send();
  
  return { txHash: tx };
}
```

---

## ðŸ”„ **COMPLETE FLOW DIAGRAM**

### **Deposit Flow**
```
1. User connects Web3Auth â†’ Gets unique address (0x... or T...)
2. User sends USDT from external wallet â†’ User's Web3Auth address
3. Backend deposit watcher detects transaction
4. Backend verifies transaction on blockchain
5. Backend credits user's platformScore
6. User can now play games with platformScore
```

### **Withdrawal Flow**
```
1. User requests withdrawal (frontend)
2. Frontend gets user's private key from Web3Auth
3. Frontend encrypts private key and sends to backend
4. Backend checks ACTUAL USDT balance on blockchain (user's Web3Auth address)
5. Backend validates amount <= actual balance
6. Backend uses user's private key to create wallet instance
7. Backend executes transfer FROM user's Web3Auth address TO user's withdrawal address
8. Backend deducts platformScore (mirrors withdrawal)
9. Transaction confirmed on blockchain
```

---

## âš ï¸ **IMPORTANT CONSIDERATIONS**

### **1. Gas Fees**
- **BEP20**: User needs BNB in their Web3Auth account for gas
- **TRC20**: User needs TRX in their Web3Auth account for gas (Energy/Bandwidth)
- **Solution**: Inform users they need native tokens for withdrawals

### **2. Private Key Security**
- âœ… Never store private keys in database
- âœ… Encrypt private keys before sending to backend
- âœ… Use private key only for transaction, then discard
- âœ… Consider using Web3Auth's signing service (if available)

### **3. Balance Synchronization**
- Frontend displays: **Web3Auth wallet USDT balance** (real-time from blockchain)
- Backend validates: **Web3Auth wallet USDT balance** (not platformScore)
- Platform Score: **Virtual balance** for gameplay only

### **4. Error Handling**
- Insufficient balance â†’ Show actual balance from blockchain
- Insufficient gas â†’ Inform user they need BNB/TRX
- Transaction failure â†’ Revert platformScore deduction
- Network errors â†’ Retry mechanism

---

## ðŸ“ **UPDATED DTO STRUCTURE**

```typescript
// withdraw.dto.ts
export class WithdrawDto {
  @IsEnum(['BEP20', 'TRC20'])
  network: string;

  @IsNumber()
  @Min(0.01)
  amount: number;

  @IsString()
  toAddress: string; // User's chosen withdrawal address

  @IsString()
  fromAddress: string; // User's Web3Auth account address

  @IsString()
  encryptedPrivateKey: string; // âœ… Encrypted user's private key from Web3Auth
}
```

---

## ðŸŽ¯ **SUMMARY**

### **Key Changes Required:**

1. âœ… **Remove admin wallet dependency** for withdrawals
2. âœ… **Use user's Web3Auth private key** for withdrawals
3. âœ… **Validate against blockchain balance**, not platformScore
4. âœ… **Transfer from user's Web3Auth address**, not admin wallet
5. âœ… **Encrypt private keys** before sending to backend
6. âœ… **Never store private keys** in database

### **Benefits:**
- ðŸ”’ **Security**: Each user controls their own funds
- ðŸ”’ **No shared wallet risk**: No single point of failure
- âœ… **Transparency**: Users see their real balance on blockchain
- âœ… **User ownership**: Funds stay in user's Web3Auth account until withdrawal

---

## ðŸ“š **References**

- Web3Auth Documentation: https://web3auth.io/docs
- BSC Documentation: https://docs.binance.org/smart-chain/
- TRON Documentation: https://developers.tron.network/
- Ethers.js: https://docs.ethers.org/
- TronWeb: https://developers.tron.network/docs/tronweb-intro

